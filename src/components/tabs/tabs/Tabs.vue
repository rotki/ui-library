<script lang="ts" setup>
import { useRoute } from 'vue-router';
import { type ContextColorsType } from '@/consts/colors';
import Button from '@/components/buttons/button/Button.vue';
import Icon from '@/components/icons/Icon.vue';
import { type Props as TabProps } from '@/components/tabs/tab/Tab.vue';

export interface Props {
  color?: ContextColorsType;
  vertical?: boolean;
  disabled?: boolean;
  grow?: boolean;
  modelValue?: number | string;
  align?: 'start' | 'center' | 'end';
}

defineOptions({
  name: 'RuiTabs',
});

const props = withDefaults(defineProps<Props>(), {
  color: undefined,
  vertical: false,
  disabled: false,
  grow: false,
  modelValue: undefined,
  align: 'center',
});

const emit = defineEmits<{
  (e: 'update:modelValue', modelValue: number | string): void;
}>();

const { color, grow, modelValue, disabled, vertical, align } = toRefs(props);

const internalModelValue = ref();

const slots = useSlots();
const children = computed(() => {
  const tabs = slots.default?.() ?? [];
  const currentModelValue = get(internalModelValue);
  const inheritedProps = {
    color: get(color),
    grow: get(grow),
    disabled: get(disabled),
    vertical: get(vertical),
    align: get(align),
  };
  return tabs.map((tab, index) => {
    let tabValue = index;
    if (tab.props?.link !== false && tab.props?.to) {
      tabValue = tab.props.to;
    }
    const active = currentModelValue === tabValue;
    return {
      ...tab,
      props: {
        tabValue,
        active,
        ...inheritedProps,
        ...tab.props,
      },
    };
  });
});

const updateModelValue = (newModelValue: string | number) => {
  emit('update:modelValue', newModelValue);
  set(internalModelValue, newModelValue);
};

const isPathMatch = (
  path: string,
  { exactPath, exact }: { exactPath?: boolean; exact?: boolean },
) => {
  const route = useRoute();
  const currentRoute = route.fullPath;

  if (exactPath) {
    return currentRoute === path;
  }
  const routeWithoutQueryParams = new URL(path, window.location.origin)
    .pathname;

  if (exact) {
    return currentRoute === routeWithoutQueryParams;
  }
  return currentRoute.startsWith(routeWithoutQueryParams);
};

onMounted(() => {
  if (get(modelValue) !== undefined) {
    return;
  }
  const enabledChildren = get(children).filter(
    (child) => !child.props.disabled,
  );
  if (enabledChildren.length > 0) {
    let newModelValue: string | number = enabledChildren[0].props.tabValue;
    enabledChildren.forEach((child) => {
      const props = child.props as TabProps;
      if (props.link !== false && props.to && isPathMatch(props.to, props)) {
        newModelValue = props.to;
      }
    });
    updateModelValue(newModelValue);
  }
  keepActiveTabVisible();
});

const css = useCssModule();

const bar = ref<HTMLDivElement>();
const wrapper = ref<HTMLDivElement>();

const { width, height } = useElementSize(bar);
const { width: wrapperWidth, height: wrapperHeight } = useElementSize(wrapper);
const { arrivedState, x, y } = useScroll(bar, { behavior: 'smooth' });

const { top, bottom, left, right } = toRefs(arrivedState);

const showArrows = computed(() => {
  if (!get(vertical)) {
    return get(wrapperWidth) > get(width);
  }

  return get(wrapperHeight) > get(height);
});

const prevArrowDisabled = computed(() => {
  if (!get(vertical)) {
    return get(left);
  }

  return get(top);
});

const nextArrowDisabled = computed(() => {
  if (!get(vertical)) {
    return get(right);
  }

  return get(bottom);
});

const onPrevSliderClick = () => {
  if (!get(vertical)) {
    set(x, get(x) - get(width));
  } else {
    set(y, get(y) - get(height));
  }
};

const onNextSliderClick = () => {
  if (!get(vertical)) {
    set(x, get(x) + get(width));
  } else {
    set(y, get(y) + get(height));
  }
};

const keepActiveTabVisible = () => {
  nextTick(() => {
    if (!get(showArrows)) {
      return;
    }

    const elem = get(wrapper);
    const barElem = get(bar);
    if (elem) {
      const activeTab = (elem.querySelector('.active-tab') ??
        elem.querySelector('.active-tab-link')) as HTMLElement;

      if (!activeTab || !barElem) {
        return;
      }

      const childLeft = activeTab.offsetLeft - elem.offsetLeft;
      const childTop = activeTab.offsetTop - elem.offsetTop;
      const childWidth = activeTab.offsetWidth;
      const childHeight = activeTab.offsetHeight;
      const parentScrollLeft = barElem.scrollLeft;
      const parentScrollTop = barElem.scrollTop;
      const parentWidth = barElem.offsetWidth;
      const parentHeight = barElem.offsetHeight;

      const scrollLeft = Math.max(
        Math.min(parentScrollLeft, childLeft),
        childLeft + childWidth - parentWidth,
      );

      const scrollTop = Math.max(
        Math.min(parentScrollTop, childTop),
        childTop + childHeight - parentHeight,
      );

      barElem.scrollTo({
        left: scrollLeft,
        top: scrollTop,
        behavior: 'smooth',
      });
    }
  });
};

useResizeObserver(bar, () => {
  keepActiveTabVisible();
});

watchImmediate(modelValue, (modelValue) => {
  set(internalModelValue, modelValue);
});

watch(internalModelValue, () => {
  keepActiveTabVisible();
});
</script>

<template>
  <div :class="[css.tabs, { [css['tabs--vertical']]: vertical }]">
    <div
      v-if="showArrows"
      :class="[css.arrow, { [css['arrow--vertical']]: vertical }]"
    >
      <Button
        class="w-full h-full !rounded-none"
        variant="text"
        :color="color"
        :disabled="prevArrowDisabled"
        @click="onPrevSliderClick()"
      >
        <Icon :name="vertical ? 'arrow-up-s-line' : 'arrow-left-s-line'" />
      </Button>
    </div>
    <div
      ref="bar"
      class="no-scrollbar"
      :class="[
        css['tabs-bar'],
        { [css['tabs-bar--vertical']]: vertical },
        { [css['tabs-bar--grow']]: grow },
      ]"
    >
      <div
        ref="wrapper"
        role="tablist"
        :class="[
          css['tabs-wrapper'],
          { [css['tabs-wrapper--vertical']]: vertical },
          { [css['tabs-wrapper--grow']]: grow },
        ]"
      >
        <Component
          :is="child"
          v-for="(child, i) in children"
          :key="i"
          @click="updateModelValue($event)"
        />
      </div>
    </div>
    <div
      v-if="showArrows"
      :class="[css.arrow, { [css['arrow--vertical']]: vertical }]"
    >
      <Button
        class="w-full h-full !rounded-none"
        variant="text"
        :color="color"
        :disabled="nextArrowDisabled"
        @click="onNextSliderClick()"
      >
        <Icon :name="vertical ? 'arrow-down-s-line' : 'arrow-right-s-line'" />
      </Button>
    </div>
  </div>
</template>

<style lang="scss" module>
.tabs {
  @apply flex h-[2.625rem];

  &--vertical {
    @apply h-auto max-h-full flex-col;
  }

  &-bar {
    @apply max-h-full overflow-auto;

    &--vertical,
    &--grow {
      @apply w-full;
    }
  }

  &-wrapper {
    @apply h-full inline-flex max-w-none;

    &--vertical {
      @apply flex-col h-auto;
    }

    &--vertical,
    &--grow {
      @apply min-w-full;
    }
  }
}

.arrow {
  @apply h-full w-10;

  &--vertical {
    @apply min-h-[2.625rem] w-full h-auto;
  }
}
</style>
